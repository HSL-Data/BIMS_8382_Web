---
title: "Intro to RNASeq"
author: "Katie Owsiany, MD/PhD student"
date: "ko8xh@virginia.edu"
---
[Back to the main page](https://bims8382.netlify.com/)

#Welcome to RNAseq analysis with DESeq2 workshop!


##Outline: 

1. First we will go over the basics of how to preprocess sequencing data that you would get from the UVA genomics core, or another sequenicing service, to the point where we can analyize differential gene expression in R using DESeq2.
2. We will spend most of the time analyzing differential expression using DESeq2 in R
3. Then we will do KEGG and GO pathway analysis 

Recommended reading and manuals: 
[DESeq2 paper](https://www.ncbi.nlm.nih.gov/pubmed/25516281)
[source paper for our data](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4903174)
[paper](https://www.ncbi.nlm.nih.gov/pubmed/24227677) and [manual](https://github.com/alexdobin/STAR/blob/master/doc/STARmanual.pdf) for STAR and [featureCounts](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4631051/) 

First let's go over preprocessing. The steps for this can vary a lot depending on the goals of your experiment and setup. But, to give you at least an overview of the steps involved, I'll walk us though an analysis I did using sequencing output from UVA genomics core sequencing facility in class. A full discussion is available in an optional tutorials [here](RNAseq_preprocessing_on_Rivanna.html) and [here](RNAseq_preprocessing_2-_transcript_quantification_.html)


let's load the packages we will need for analysis today 

```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE} 
library(tidyverse)

if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install("DESeq2", version = "3.8")
library(DESeq2)

BiocManager::install('recount')
library(recount)

BiocManager::install('biomaRt')
library(biomaRt)

BiocManager::install("gage")
library(gage)

BiocManager::install("pathveiw")
library(pathview)

BiocManager::install("gageData")
library(gageData)

```

After preprocessing, you should have a .txt file corresponding to counts of genes mapped by featureCounts in your samples.  You can download these files from Rivanna to your computer using globus. However, today we will use a pre-processed count matrix available from [recounts](https://jhubiostatistics.shinyapps.io/recount/), which is a great database of publicly available pre-processed RNAseq data. Today we will be using data from [this paper](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4903174). They did an experiment comparing RNAseq transcripts regulated differently between circulating lymphatic and endothelial progenitor cells isolated from whole blood samples. 

We will import this into an object called mycounts in R using read_csv. 

##Download studies from recount 

Let's load today's study. Navigate to shiny app for the database [here](https://jhubiostatistics.shinyapps.io/recount/).

```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
endo <- download_study("SRP035883")
load(file.path('SRP035883', 'rse_gene.Rdata'))
rse<- scale_counts(rse_gene)
endo_counts <- assays(rse)$counts
head(endo_counts)
```

Let's make our row names something we can call on later. First, make endo_counts into a dataframe.

```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
endo_counts<- as.data.frame(endo_counts)
endo_counts$ensembl_gene_id_version<- rownames(endo_counts)
row.names(endo_counts) <- NULL
endo_counts<- endo_counts[,c(13, 1:12)]
head(endo_counts)
```
If you get lost, you can also read in endo_counts from course materials using read_csv

```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
endo_counts <- read_csv("endo_counts.csv")
```

#Load metadata
DESeq2 requires a second file with metadata, or basically a table that describes your samples. For my own experiment, I made this file myself simply by making a table listing my sampleIDs (which are the basenames of the files, GreenAth_S5_L001) and which experimental group they were in. If you make this in Excel be sure to save as a .csv and not .xlsx!  Today we'll also use a prepared metadata file. You can get metadata from recounts by calling colData on the dataset we did earlier. I did a little data tidying ahead of time, so for now just load the endo_metadata file. 

```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
#This is how you would get metadata from recounts
#endo_metadata<-colData(rse) %>%
  #as.data.frame()

#Read in metadata file using read_csv
endo_metadata <- read_csv(file = "endo_metadata.csv")
head(endo_metadata)

#make sure all of these are dataframes. 
endo_metadata<- as.data.frame(endo_metadata)
```
Make sure the sampleIDs in the rows of your metadata file match the names of the columns in your count matrix! How would you check this?

**Exercise 1**

1. You can see that here we have two groups of samples named SRR1145636, etc. Use the metadata file to make a new column in the endo_counts data showing the average expression of genes in control vs treated samples.  Put this in a new object called meancounts. `hint: meancounts<-endo_counts%>%mutate(lymphmean = (SRR1145636+SRR1145638+...)`


```{r, echo=FALSE, results='hide', collapse=TRUE, warning = FALSE, message=FALSE} 
meancounts<- endo_counts%>%
  mutate(lymphmean = (SRR1145636+SRR1145638+SRR1145637+SRR1145645+SRR1145646+SRR1145647)/6) %>%
  mutate(bloodmean = (SRR1145639+SRR1145641+SRR1145640+SRR1145642+SRR1145643+SRR1145644)/6)
```
2. Use summarize() to compare the total number of averaged counts across all genes

3. Plot the meancounts for all genes in lymphmean and bloodmean using ggplot()+geom_point() on a log10 scale for both x and y axis


##Test out mean count data as quantification and get annotations
Next, we will use the meancounts object to get log2 fold change data for each gene. 
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
meancounts <- meancounts %>%
  filter(bloodmean>0 & lymphmean>0)%>%
  mutate(log2fc= log2(bloodmean/lymphmean))

#upregulated transcripts
meancounts %>%
  filter(log2fc>0)%>%
  head()
```

This gets us a list of upregulated transcripts, but we don't know what genes they are! The last thing that you will need is an annotation file that contains information about each gene like name, description, ensembl ID, and entrezID- basically a conversion chart for genes that allow us to use this data with several different packages. We will download human annotation tables, but many more species are available. [link to user guide for biomarRt](https://www.bioconductor.org/packages/devel/bioc/vignettes/biomaRt/inst/doc/biomaRt.html#how-to-build-a-biomart-query)

```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
#?useMart
ensembl= useMart("ensembl")
ensembl= useDataset("hsapiens_gene_ensembl", mart=ensembl)
anno<- getBM(attributes= c("ensembl_gene_id_version", "ensembl_gene_id", "entrezgene", "hgnc_symbol", "description"), mart=ensembl)
```
Names are important when handling high dimensional biological data- the HNGC is an international organization that regulates the names given to unique genes so that the same transcript isn't named two different things and there is no more than one consensus name for a given gene. More on hngc at genenames.org. 

Let's make our data more interpretable by converting the ENSG codes into gene names. Use inner_join to join the anno object to endo_counts by "ensembl_gene_id_version"

```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
endo_counts_annotated<-inner_join(endo_counts, anno)
head(endo_counts_annotated)
```


**Exercise 2**

1.Navigate to genenames.org and look up the HNGC consensus gene symbol for CD45. CD3? F4/80? Sox9?
2. Use inner_join to merge your anno table with meancounts. Use  arrange() to list genes by the highest log2fold change between blood and lymph samples.

##DESEq2
Ok now that we have our count, col, and anno files let's move on to DESeq2. Take a look at the function DESeqDataSetFromMatrix.

```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
#?DESeqDataSetFromMatrix
```
DEseq2 will not take a tibble or metadata, MUST be a dataframe ONLY
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
endo_counts<-as.data.frame(endo_counts)
endo_metadata<-as.data.frame(endo_metadata)
```
Also remember the first row of count data MUST match the first column of col data. Let's make an object dds that is a container that stores datasets, as well as results tables, or "assays" and processes
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
dds<- DESeqDataSetFromMatrix(endo_counts, endo_metadata, ~celltype, tidy=TRUE)
```
It's ok if you converted counts to integers (we started out with counts normalized for transcript length).


Now let's run DESEq2! This will do all the DEseq package analyses, including dispersions, fitting model etc.
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
?DESeq
```
DESeq is a wrapper function that performs three other main functions: 

1. estimate size factors. This is to factor in the depth of the sequencing in different samples If size of individual genes (some genes get picked up more easily just because they are longer, and so have more reads mapped to them) or genome GC content, indels, copy number variation etc. are of particular concern in your experiment, you can provide a matrix of normalization factors for each gene or region of interest under the argument normMatrix of estimateSizeFactors.

2. estimate dispersion. (we will graph below)


3. fit the results to a binomial linear model, this is a negative binomial GLM with Wald statistics. This builds a linear model and determines which genes drive that variation, ie can a gene be removed from the dataset and change the shape of the model. Those genes that are "determining" for the model are examined for differences between the experimental groups that tests the null hypothesis that log2 Fold change expression between treated and control samples is 0, and that variation between the genes on average will follow a normal distribution.
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
dds<- DESeq(dds)
```
To get the results we need to make another object that we can convert back into a tibble for data tidying and interpretation
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
res<- results(dds, tidy=TRUE)
```
Notice by using `?res` that there are many options for arguments here! independent filtering- allows the program to drop genes that have high variability or low counts to reduce multiple testing correction. default is true.

**Exercise 3** 

1. How many genes have an adjusted p value less than or equal to 0.05?

2. now let's link up gene names and descriptions and export our significantly regulated genes. HINT: use inner_join to make a new object called res_annotated. Note that in the res table, ensembl_gene_id_version is called "row." You will have to do something like inner_join(anno, by  c("row"= "ensembl_gene_id_version")). Export genes with padj< 0.05 using write_csv().

```{r, echo=FALSE, results='markup', collapse=TRUE, warning = FALSE, message=FALSE} 
res_annotated<-res %>%
  arrange(padj) %>%
  inner_join(anno, by=c("row" = "ensembl_gene_id_version"))
head(res_annotated)
```

##Data Visualization
Plot dispersion. This will give you an idea of the dispersion of your genes between replicates.  
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
plotDispEsts(dds)
```

DESeq2 estimates dispersion by assuming dispersion is roughly the same for genes that are of the same expression level. However, it does not change dispersion for high count outliers and increases dispersion on low counts to avoid false positives and conserve variability that is likely due to biological instead of technical factors.

Take a look at a gene of interest, NLGN1
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
res_annotated %>%
  filter(hgnc_symbol == "NLGN1")

#plot the counts of NRG1 between blood and lymph samples
plotCounts(dds, gene = "ENSG00000169760.17", intgroup = "celltype", returnData= TRUE)%>%
  ggplot(aes(celltype, count))+geom_boxplot(aes(fill=celltype))+scale_y_log10()+labs(title="NLGN1")
```

Let's make plots that show us the relationship between expression of genes and their fold change. An MA plot shows the average expression on the X-axis and the log fold change on the y-axis. A volcano plot shows us genes with high log fold change and low p value. In a volcano plot the log fold change on the X-axis, and the −log10 of the p-value on the Y-axis (the more significant the p-value, the larger the −log10 of that value will be).


Make a new column in res to signify if a gene is significant or not. Then, make an MA plot. Use a log10 scaled x-axis, color-code by whether the gene is significant, and give your plot a title.
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
res<- res%>%
  mutate(sig=padj<0.05)

res%>%
  ggplot(aes(x=baseMean, y=log2FoldChange))+geom_point()+aes(color=sig)+labs(title="MA Plot")+scale_x_log10()

```

The gray points are ones that were filtered for testing correction, so really low counts which therefore have no adj p value. DESeq allows us to detect significant differences even if fold change is small, in highly expressed genes with low variance.

**Exercise 4**

1.Make a volcano plot graphing log fold change on the x axis and -log10 of the pvalue on the y axis, again colored by significance. Results should look like this: 
```{r, echo=FALSE} 
res %>%
  filter(!is.na(sig))%>%
  ggplot(aes(x=log2FoldChange, y=-log10(padj)))+geom_point()+aes(color=sig)+labs(title="Volcano plot")
```


It is very useful to look at a principal component analysis (PCA) to detect batch effect or mislabeled samples. To use PCA, first we must use a transformation of the data. There are several, we will use variance stabilizing.
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
vsdata <- vst(dds, blind=FALSE)  
plotPCA(vsdata, intgroup= "celltype")
```

Principal component analysis reveals two samples, one in the control group and one in the treated group, with a lot of variance with respect to the the others. Were they from the same experimental batch? Did they run on the same lane of the sequencer? How would you find out which samples are outliers in the PCA plot? (Hint: use the environment window to examine the variables in vsdata object. What else could you make the intgroup in plotPCA(, intgroup = "celltype")?) 

##Pathway analysis 
To do pathway analysis on our results, first we must load the datasets that correspond to the pathways.
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
data("kegg.sets.hs")
data("sigmet.idx.hs")
```
Note that we are loading HUMAN gene sets, if you want to use mouse you need to use kegg.sets.mm- the last two letters are the genus and species you are looking for. We are going to limit our search to kegg sets that have to do with biological processes. 
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
kegg.sets.hs<- kegg.sets.hs[sigmet.idx.hs]
#take a look at this object
lapply(kegg.sets.hs[1:3], head)
```
The gage() function requires a vector of fold changes, where the names of the values are the Entrez gene IDs.
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
foldchanges<- res_annotated$log2FoldChange
names(foldchanges)<- res_annotated$entrezgene
head(foldchanges)
```
Use the function gage to get a new object keggres with significant pathways. We will opt to look for pathways where all the genes are coregulated in the same direction.
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
keggres<- gage(foldchanges, gsets= kegg.sets.hs, same.dir = TRUE)
lapply(keggres, head)
```
Same.dir can also be set to false, but gives paths only enriched, not up or down.
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
keggres<- gage(foldchanges, gsets= kegg.sets.hs, same.dir = FALSE)
lapply(keggres, head)
```
Make a new object of significant pathways using sigGeneSet.
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
keggres_sig<-sigGeneSet(keggres)
```
See that there is one sig pathway up, none down. 

We can also make plots of the pathways and see how individual components of that pathways are up or downregulated through shading in red and green. This will create several files in your base directory plotting the 5 pathways we chose above

```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
#keggrespathways = data.frame(id=rownames(keggres$greater), keggres$greater) %>% tbl_df() %>% filter(row_number()<=5) %>% .$id %>% as.character()
#keggresids = substr(keggrespathways, start=1, stop=8)
#plot_pathway = function(pid) pathview(gene.data=foldchanges, pathway.id=pid, species="hsa", new.signature=FALSE) 
#tmp = sapply(keggresids, function(pid) pathview(gene.data=foldchanges, pathway.id=pid, species="hsa"))

```


GO analysis works similarly. First, load the terms. go.set.hs has all GO terms, go.subs.hs has only the BP, CC, and MF, of which we will select biological proccesses. 
```{r, echo=TRUE, results='markup', collapse=TRUE, message=FALSE}
data("go.sets.hs")
data("go.subs.hs")
gobpsets <- go.sets.hs[go.subs.hs$BP]
```

**Exercise 5**

1. Repeat your pathway analysis of the data using gage, this time searching for the GO terms we read in above. Make a significant gene set object and write the values using write_csv() 


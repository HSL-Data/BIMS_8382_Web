---
title: "Data Visualization"
author: "David Martin"
date: "February 25, 2019"
output: html_document
---

[Back to the main page](https://bims8382.netlify.com/)


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data Visualization
We will first load up the tidyverse since we will be using the dplyr, ggplot, and readr packages.
```{r, message = FALSE}
library(tidyverse)
```

read in data

```{r}
brauer <- read_csv("Data/brauer2007_tidy.csv")
```

We are going to make a smaller version of this data, for time sake

```{r}
brauer <- brauer[seq(1, nrow(brauer), 5), ]
gm <- read_csv("Data/gapminder.csv")
```

Refreshing skills from last week

###DPLYR
filter -- select certain rows

Just do a quick filter.
```{r}
head(filter(brauer, symbol == "SFB2"))
head(filter(brauer, expression < 0 & symbol == "SFB2"))
```

```{r}

#THE PIPE
brauer %>% 
  filter(symbol == "SFB2")  %>% 
  head()

```

PART 1.99 - PLOTTING in Base R

```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
plot(gm$lifeexp, gm$gdpPercap)
```

note about qplot: Encompasses many options and defaults, but not as flexible as ggplot.

```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
qplot(data = gm, x = continent, y = lifeexp, geom = "boxplot")
```

##ggplot2
 `geom` -- plot type (point, bar, histogram, etc.)
 `aesthetics` -- variables mapped onto plot (axes and size, shape, color etc)
 `stat` -- statistical summary or transform in plot
 `facets` -- way to slice data on certain variable

### Two Continous Variables
### Point, jitter, quantile, smooth, etc.
This will create a blank canvas to add layers upon.
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
ggplot()
```

`data = gm` uses the `gm` dataset and a call to aes indicates the variables to be used.
However, the graph will still be empty until we specify the type of graph to use.
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
ggplot(data = gm, aes(x = gdpPercap, y = lifeexp))
```
Add the geom (plot type), which will be point. (Essentially a scatter plot)
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
ggplot(data = gm, aes(x = gdpPercap, y = lifeexp)) + geom_point()
```

Save the canvas to a variable

```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p <- ggplot(gm, aes(x = gdpPercap, y = lifeexp))
p
```
You can then slowly add on each layer, starting with adding the point geom to p
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p <- p + geom_point()
  p
```
You can also go ahead and test out other ggplot options
Let's try to use one of the scaling functions. (check ggplot2 cheatsheet for other scale options)
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p + scale_x_log10()
p + scale_x_sqrt()

#I think the log10() looks nice, lets make sure we save this back to p
p <- p + scale_x_log10()
p
```

This graph looks ok, but it could use something else. 
You can use an option within the `geom_point` function to color the individual points by different values within the data. 
Example: Coloring the points by continent.
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p + geom_point(aes(color = continent))
```

The `aes` wrapper allows for the color to differentiate based upon variable values.

Without wrapping the color option in an `aes` call, the color can be applied in a blanket way across all points.

```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p + geom_point(color = "blue")
```
Here are a list of colors that are available in R. Put any of those in the color = "color" and it will change the color.

```{r}
colors()
```

Within the `geom_point` function you can also change the symbol type (`pch`), the size of the symbol (`size`), and the transparency of the symbol (`alpha`)

```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p + geom_point(color = "red", pch = 12, size = 6, alpha = 1)
```

Using `aes` within the `geom_point` function allows you to use the above options and apply them across several variable values.

Essentially there is a bit of a dynamic vs. static situation here.

```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p + geom_point(aes(color = continent, shape = continent, size = lifeexp))
```

Change shape, color, size to be mapped to variables

So here the size of the point is determined by lifexp, and the color and shape of the dot are determined by the value for continent

You can also combine the use of an `aes` call with the use of options outside of an `aes` call.

```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p + geom_point(aes(color = continent), size = 3, pch = 3)
```

This allows you to both apply specific options to various values and change the overall appearance to all values.

###Exercise 1
1. Start with the `ggplot()` function using the gm data.

2. Create an aesthetic mapping of `gdpPercap` to the x-axis and `total_perthou` to the y-axis.

3. Add points to the plot: Make the points size 3, use `pch = 25`, and map continent onto the aesthetics of
the point

4. Use a `scale_x_reverse` scale for the x-axis.

----------------------------------------------------

Adding to your plot

```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}

p <- ggplot(gm, aes(gdpPercap, lifeexp)) + scale_x_log10()
p
```

Add in a smoothing line to better understand the relationships in your data.
Smoothing line defaults to using the loess method.

```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p + geom_point() + geom_smooth()
p + geom_smooth()
```

###Adding a smoothing line

Like in geom_point(), you can change the options within geom_smooth.
Here we can change the method to a linear model (lm), Choose not to display confidence intervals (se), change the line width (lwd) to 2, and the line color (col) to red.
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p <- p + geom_point() + geom_smooth(lwd = 2, se = FALSE, method = "lm", color = "red")

# You can also combine this with changing the look of your data points
p + geom_point(aes(color = continent))
```


###Faceting
Facets divide a plot into subplots based off of the values of a variable.
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p <- ggplot(gm, aes(gdpPercap, lifeexp)) + scale_x_log10()

#To use facets, you use the function facet wrap.
p + geom_line() + facet_wrap(~continent)
p + geom_line() + facet_wrap(~country)
```

Here we will use geom_line to create line graphs
Watch out when using this to make sure you aren't breaking things up too much.
Facet wraps allow for options as well. 
`ncol` provides the number of columns you want to use to display the graphs.

```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p + geom_line() + facet_wrap(~continent, ncol = 5)
```

##Saving plots
```{r}
ggsave(file = "gdp_lifeexp.png")
```

However, we may want to add some smoothing lines to each facet and change to `geom_point`, etc.
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
pfinal <- p + geom_point() + geom_smooth() + facet_wrap(~continent, ncol = 1)
pfinal
```

Can save as a pdf and other formats.

```{r}
ggsave(pfinal, file = "finalplot.pdf", width = 5, height = 15)
```

#Filtering your facets
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p <- ggplot(filter(gm, year >= 1997), aes(gdpPercap, lifeexp)) + scale_x_log10()
p
p + geom_point() + facet_wrap(~year)
```

##Exercise 2
1. Make a scatter plot of `lifeexp` on the y-axis against `year` on the x.
2. Make a series of small multiples faceting on continent.
3. Add a fitted curve, smooth or lm, with and without facets.
Bonus: using `geom_line()` and and aesthetic mapping `country` to `group=`, make a "spaghetti plot",
showing semitransparent lines connected for each country, faceted by continent. Add a smoothed loess
curve with a thick (`lwd=3`) line with no standard error stripe. Reduce the opacity (`alpha=`) of the
individual black lines. Don't show Oceania countries (that is,`filter()` the data where
`continent != "Oceania"` before you plot it).


## One categorical variable, one continuous variable.
   Country vs. deaths
   Gender vs. lifeexp
   etc,
   Bar, Boxplot, dotplot, violin
 
   X = categorical, Y = continuous
   
expression by nutrient
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p <- ggplot(brauer, aes(x = nutrient, y = expression))
p
```

Lets how it looks with points

```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p + geom_point()
```

Add transparency to the points

```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p + geom_point(alpha = 1/4)
# Add a bit of stagger to the points
p + geom_jitter()

# And some transparency
p + geom_jitter(alpha = 1/4)
```

A boxplot may make a bit more sense.
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p + geom_boxplot()

#add jitter to a boxplot
p + geom_boxplot() + geom_jitter(alpha = 1/2)

```

###ORDER MATTERS
boxplot on top instead 
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p + geom_jitter() + geom_boxplot()

#We should go ahead and make the box plot stand out a bit.
p + geom_jitter() + geom_boxplot(color = "red", fill = "blue")
```

We can also do a violin plot as well. 
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p + geom_violin()
  p + 
    geom_violin() + 
    geom_jitter(aes(color = nutrient), alpha = 1/4)
```

using the pipe 
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
brauer %>% 
  ggplot(aes(x = nutrient, y = expression)) + 
  geom_violin() + 
  geom_jitter(aes(color = nutrient), alpha = 1/4)
```

Using Filter to narrow things down
Also quite useful for handling Nas
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
#filter()
```

Reorder allows for you to reorder the axis labels
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p <- ggplot(brauer, aes(x = reorder(nutrient, rate), y = expression))
p 
p + geom_boxplot()
```

##Exercise 3
1. Make a jittered strip plot of `GDP per capita` against `continent` .

2. Make a box plot of `GDP per capita` against `continent`.

3.Using a log10 y-axis scale, overlay semitransparent 
jittered points on top of box plots, where outlying
points are colored.

4. BONUS: Try to reorder the continents on the x-axis by `GDP per capita`. Why isn't this working as
expected? See `?reorder` for clues.

##Univariate plots: histograms, density, bar, dotplot

histograms

```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p <- ggplot(brauer, aes(expression))
p <- p + geom_histogram()
  p 
```

choose different number of bins
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p + geom_histogram(bins = 15)
p + geom_histogram(binwidth = 2.5)
p + geom_histogram(binwidth = .2)
p + geom_histogram(breaks = c(-5, -2, 0, 2, 5))
```

density plots
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p <- ggplot(brauer, aes(expression))
  p + geom_density()
```

color univariate plots
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
  p + geom_histogram(aes(color = nutrient))
  
  p + geom_histogram(aes(fill = nutrient), position = "identity")
  
#Alpha provides the transparency of each layer.  
  p <- p + geom_histogram(aes(fill = nutrient), position = "identity", alpha = 1/3)
  p
  
#can facet these histograms
  p <- p + facet_wrap(~nutrient)
  p  
#we can look at this same chart as a density curve
  p <- ggplot(brauer, aes(expression))
    
  p + geom_density(aes(color = nutrient, fill = nutrient), alpha = 1/3, size = 1)
  
  p + geom_density(aes(color = nutrient, fill = nutrient)) + facet_wrap(~nutrient)
```

###Exercise 4
1. Plot a histogram of GDP Per Capita.

2. Do the same but use a log10 x-axis.

3. Still on the log10 x-axis scale, try a density plot mapping continent to the fill of each density distribution,
and reduce the opacity.

4. Still on the log10 x-axis scale, make a histogram faceted by continent and filled by continent. Facet with a
single column (see ?facet_wrap for help).

5. Save this figure to a 6x10 PDF file.


##Changing the look of your plots

Adding Reference Lines
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p <- ggplot(gm, aes(x = total_perthou, y = lifeexp))
p

p <- p + geom_point(aes(color = death_cat), size = 3)
p

p <- p + geom_vline(xintercept = c(550, 725), size = 2, color = c("firebrick", "blue"), alpha = 1/4)
p
```

Let us go ahead and build up a nice base plot to use.
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p <- ggplot(gm, aes(gdpPercap, lifeexp))
p <- p + scale_x_log10() + 
     aes(color = continent) +
     geom_point() + 
     geom_smooth(se = FALSE, lwd = 2)

#Changing the Title
p <- p + ggtitle("Life Expectancy vs. GDP by Continent")
p

title <- ggtitle("Life Expectancy vs. GDP by Continent")
```

Changing the X and Y axis labels
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p <- p + xlab("GDP Per Capita (USD)") + ylab("Life Expectancy (years)")
p

xlabs <- xlab("GDP Per Capita (USD)")
ylabs <- ylab("Life Expectancy (years)")
```

To add a caption
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
p <- p + labs(caption = "(Data from gapminder.csv)")
p
caps <- labs(caption = "(Data from gapminder.csv)")
```


Using theme() you can control many different ggplot() elements.
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
#?theme()
new_theme <- theme(legend.position = "bottom", 
        axis.text = element_text(color = "red"),
        panel.background = element_rect(fill = "mistyrose2"),
        plot.title = element_text(size = 20, color = "orange"),                                  
        axis.title = element_text(size = 14, color = "sienna")
        )

p + new_theme

# Themes to speed up formatting
p <- ggplot(gm, aes(gdpPercap, lifeexp))
p <- p + scale_x_log10() + 
  aes(color = continent) +
  geom_point() + 
  geom_smooth(se = FALSE, lwd = 2)
p

p + title + caps + xlabs + ylabs
p <- ggplot(gm, aes(gdpPercap, lifeexp))
p <- p + scale_x_log10() + 
  aes(color = continent) +
  geom_point() + 
  geom_smooth(se = FALSE, lwd = 2)

p

p + theme_bw() + theme(legend.position = "none")
p + theme_classic()
```


The ggthemes package has built in themes to mimic certain publications, etc.
```{r, fig.fullwidth=TRUE, fig.width=10, fig.height=6}
#install.packages("ggthemes")
library(ggthemes)
p + theme_excel() + scale_color_excel()
p + theme_gdocs() + scale_color_gdocs()
p + theme_stata() + scale_color_stata()
p + theme_wsj() + scale_color_wsj()
p + theme_economist()
p + theme_fivethirtyeight()
```